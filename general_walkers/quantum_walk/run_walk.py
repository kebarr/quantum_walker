"""\
quantum_walk

Usage:
    quantum_walk [ (( --initial_state_fn=<filename> | --initial_state=<filename>)  --i=<arg>)  (--graph_creation_fn=<filename> --coin_creation_fn=<filename> --n=<int>| --adjacency_matrix=<filename> --coin_matrix=<filename>) --output_filename=<filename>] STEPS
    quantum_walk -h
    quantum_walk --version


Create a quantum walk object and run for STEPS time steps, either with default evolution (Hadamard on 4-cycle) or user specified either by files containing function definitions as multiline strings which generate, given n, appropriate sized time evolution operators, or pickled numpy arrays of the operators to use. Result is then saved in output-filename or printed to standard out. Initial state can be autogenerated, generated by a function, or supplied as a pickled numpy array.

Arguments:
    STEPS                           Number of steps to run walk from

Options:
    --initial_state_fn=<filename>         Function to generate initial state vector
    --i=<arg>                             Parameter for initial state creation
    --initial_state=<filename>            Initial state vector
    --graph_creation_fn=<filename>        Specify structure to walk on via function
    --coin_creation_fn=<filename>         Function to generate coin
    --adjacency_matrix=<filename>         Numpy array cointaining structure
    --coin_matrix=<filename>            Numpy array containing coin
    --output_filename=<filename>          Destination to pickle results
"""

import docopt
from quantum_walk.walker import QuantumWalk, create_sample_initial_state, create_sample_time_ev_operators
import pickle


def parse_time_evolution_options(options):
    keys = [key for key in options.keys() if options[key] is not None]
    coin_matrix = None
    adjacency_matrix = None
    if "--graph_creation_fn" in keys:
        adjacency_matrix_creator = read_option(options["--graph_creation_fn"])
        coin_matrix_creator = read_option(options["--coin_creation_fn"])
        n = options["--n"]
        coin_matrix = coin_matrix_creator(n)
        adjacency_matrix = adjacency_matrix_creator(n)
    elif "--adjacency_matrix" in keys:
        coin_matrix = unpickle_option(options["--coin_matrix"])
        adjacency_matrix = unpickle_option(options["--adjacency_matrix"])
    return coin_matrix, adjacency_matrix

def parse_initial_state_options(options):
    keys = [key for key in options.keys() if options[key] is not None]
    initial_state = None
    if "--initial_state_fn" in keys:
        with open(options["--initial_state_fn"], "r") as f:
            state_vector_creator = f.read()
        initial_state = state_vector_creator(options["i"])
    elif "--initial_state" in keys:
        initial_state = unpickle_option(options["--initial_state"])
    return initial_state

def parse_walk_options(options):
    coin_matrix, adjacency_matrix = parse_time_evolution_options(options)
    initial_state = parse_initial_state_options(options)
    return initial_state, coin_matrix, adjacency_matrix



def unpickle_option(option):
    with open(option, "r") as f:
        result = pickle.load(f)
    return result

def read_option(option):
    locals = {}
    namespace = {}
    execfile(option, namespace, locals)
    result = locals.values()[0]
    return result

def run_walk():
    options = docopt.docopt(__doc__, version='0.1')
    print options
    initial_state, coin_matrix, adjacency_matrix = parse_walk_options(options)
    if not coin_matrix:
        coin_matrix, adjacency_matrix = create_sample_time_ev_operators()
    if not initial_state:
        initial_state = create_sample_initial_state()
    walk = QuantumWalk(initial_state, coin_matrix, adjacency_matrix)
    steps = options["STEPS"]
    lines = ""
    for step in xrange(int(steps)):
        walk.step()
        probs = walk.calculate_probabilities()
        if options["--output_filename"]:
            lines = lines + str(probs) + "\n"
        else:
            print probs
    if options["--output_filename"]:
        with open(options["--output_filename"], "w") as f:
            f.write(lines)


