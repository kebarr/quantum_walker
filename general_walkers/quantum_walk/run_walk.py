"""\
quantum_walk

Usage:
    quantum_walk [ ( --initial_state_fn=<filename> --state_name=<arg> --i=<arg>| --initial_state=<filename> --adjacency_matrix=<filename> --coin_matrix=<filename>) (--graph_creation_fn=<filename> --coin_creation_fn=<filename> --coin_name=<arg> --graph_name=<arg> --n=<int>) (--coin_bias=<arg> --initial_state_bias=<arg>)  --output_filename=<filename>] STEPS
    quantum_walk -h
    quantum_walk --version


Create a quantum walk object and run for STEPS time steps, either with default evolution (Hadamard on 4-cycle) or user specified either by files containing function definitions as multiline strings which generate, given n, appropriate sized time evolution operators, or pickled numpy arrays of the operators to use. Result is then saved in output-filename or printed to standard out. Initial state can be autogenerated, generated by a function, or supplied as a pickled numpy array.

Arguments:
    STEPS                           Number of steps to run walk from

Options:
    --initial_state_fn=<filename>         Function to generate initial state vector
    --i=<arg>                             Parameter for initial state creation
    --initial_state=<filename>            Initial state vector as pickled object
    --state_name=<arg>                    String of initial state function name
    --graph_creation_fn=<filename>        Specify structure to walk on via function
    --graph_name=<arg>                    String of adjacnecy matrix creation fn name
    --coin_creation_fn=<filename>         Function to generate coin
    --coin_name=<arg>                     String of coin matrix creation fn name
    --adjacency_matrix=<filename>         Pickled numpy array cointaining structure
    --coin_matrix=<filename>              Pickled numpy array containing coin
    --coin_bias=<arg>                     Number from 0 to 1 to skew coin by
    --initial_state_bias=<arg>            Number from 0 to 1 to skew initial state by
    --output_filename=<filename>          Destination to pickle results
"""

import docopt
from quantum_walk.walker import QuantumWalk, create_sample_initial_state, create_sample_time_ev_operators
from quantum_walk.walk_on_line import QuantumWalkOnLine
import pickle
from scipy.fftpack import fft
import numpy as np
import scipy.linalg


def parse_time_evolution_options(options):
    keys = [key for key in options.keys() if options[key] is not None]
    coin_matrix = None
    adjacency_matrix = None
    if "--graph_creation_fn" in keys:
        adjacency_matrix_creator = read_option(options["--graph_creation_fn"], options["--graph_name"])
        coin_matrix_creator = read_option(options["--coin_creation_fn"], options["--coin_name"])
        n = int(options["--n"])
        coin_matrix = coin_matrix_creator(n)
        adjacency_matrix = adjacency_matrix_creator(n)
    elif "--adjacency_matrix" in keys:
        coin_matrix = unpickle_option(options["--coin_matrix"])
        adjacency_matrix = unpickle_option(options["--adjacency_matrix"])
    return coin_matrix, adjacency_matrix

def parse_initial_state_options(options):
    keys = [key for key in options.keys() if options[key] is not None]
    initial_state = None
    if "--initial_state_fn" in keys:
        state_vector_creator = read_option(options["--initial_state_fn"], options["--state_name"])
        initial_state = state_vector_creator(int(options["--i"]))
    elif "--initial_state" in keys:
        initial_state = unpickle_option(options["--initial_state"])
    return initial_state

def parse_walk_options(options):
    coin_matrix, adjacency_matrix = parse_time_evolution_options(options)
    initial_state = parse_initial_state_options(options)
    return initial_state, coin_matrix, adjacency_matrix



def unpickle_option(option):
    with open(option, "r") as f:
        result = pickle.load(f)
    return result

def read_option(option, name_option):
    locals = {}
    execfile(option, locals)
    result = locals[name_option]
    return result


def initialise_walk_on_arbitrary_graph(options):
    initial_state, coin_matrix, adjacency_matrix = parse_walk_options(options)
    # if time evolution operators not specified via command line, use default
    if coin_matrix == None:
        coin_matrix, adjacency_matrix = create_sample_time_ev_operators()
    # ditto initial state
    if initial_state == None:
        initial_state = create_sample_initial_state()
    walk = QuantumWalk(initial_state, coin_matrix, adjacency_matrix)
    return walk


def run_walk():
    options = docopt.docopt(__doc__, version='0.1')
    condition = "--coin_bias" in options.keys()
    if condition:
        walk = QuantumWalkOnLine(int(options["STEPS"]), float(options["--coin_bias"]), float(options["--initial_state_bias"]))
    else:
        walk = initialise_walk_on_arbitrary_graph(options)
    steps = options["STEPS"]
    lines = ""
    for step in xrange(int(steps)):
        walk.step()
        probs = walk.calculate_probabilities()
        if options["--output_filename"]:
            lines = lines + str(probs) + "\n"
        else:
            print probs
    if options["--output_filename"]:
        with open(options["--output_filename"], "w") as f:
            f.write(lines)
    if condition:
        walk.plot()


